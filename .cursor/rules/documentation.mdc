---
description: |-
globs: 
alwaysApply: true
---
---
description: |-
  Documentation requirements
glob: "**/*.*"
alwaysApply: true
---
When generating documentation for this project (in the `docs/` directory for MkDocs), the AI should **create and maintain extremely detailed, lucid, and explanatory Markdown files** that cover every significant code element. The rule will ensure documentation is updated as the project evolves. Key guidelines include:

## Class and Function Documentation Pages

- **Identify All Code Elements:** Recursively scan the `src/` and `examples/` directories for every Python class, function, and important static variable. For each such element, create a dedicated Markdown documentation page under `docs/` (mirroring the package/module structure). This yields one file per class or function, named after that element for clarity.
- **Include Docstrings (Pydoc):** At the top of each page, include the element’s docstring (pydoc) content, ensuring that *all* methods and attributes are documented – **including private methods and variables** (e.g. those prefixed with `_`). This captures the intended usage and internal behavior of the class or function in its own words.
- **Source Code Visibility:** Provide an easy way for readers to see the source implementation of each class and method. For example, include a **syntax-highlighted code block** of the class definition and each method, or utilize MkDocstrings’ built-in **“show source”** feature to link to source code. This way, a user can click or expand to view the exact code of a method in context, which is invaluable for transparency. Each method’s signature and body (trimmed to relevant parts) can be shown in a collapsible section for neatness.
- **Detailed Description and Usage:** Begin each page with a **comprehensive introduction** describing what the class or function does, its role in the project, and how to use it. Explain the **contextual relationship** with other parts of the project – for example, mention if a class is typically used by another module or if it extends some base class. Include **usage examples** (with short code snippets) demonstrating typical use cases. This narrative should make it clear why the class/function exists and how it should be used in practice.
- **Document All Members:** For classes, list and document every method (and important attributes). Even private or helper methods should be described, to give maintainers insight into internal operations. For each method, document its purpose, parameters, return values, and any side effects or exceptions. This essentially recreates full API documentation with the depth of an internal developer guide.

## Package Overview Pages

- **Overview for Each Package:** For each Python package (directory with an `__init__.py`), create an **overview Markdown file** (e.g., an `index.md` in that package’s docs folder or a `{PackageName}.md` page). This overview clearly explains the package’s purpose and how it fits into the larger project architecture. It should list the main modules, classes, and functions contained in that package and give a one-paragraph summary of each.
- **Context and Relationships:** In the package overview, describe how the components of the package work together and how this package interacts with other parts of the project. For example, if the project is a library, explain what functionality the package provides; if it’s a feature of an application, explain the high-level workflow of that feature. This gives readers a map of the codebase’s structure.
- **Link to Detailed Pages:** The overview should provide links to the documentation pages of each class/function in the package for deeper information. This way, readers can navigate from a high-level description to the specific details easily.
- **Visual Summary:** If appropriate, include a small diagram (e.g., a module dependency graph or a high-level UML diagram) to illustrate the components in the package and their interactions.

## Visual Diagrams (UML Class & Sequence Diagrams)

- **Class Diagrams:** Utilize **Mermaid** to include UML class diagrams that illustrate relationships between classes. For each class (or group of related classes), generate a diagram showing inheritance (which classes inherit from which), composition (which classes contain or reference others), and associations. The project’s documentation is already set up to support Mermaid diagrams (the MkDocs config enables the Mermaid2 plugin and a fenced code syntax for Mermaid), so these diagrams will render automatically on the docs site. The AI can parse the code structure (e.g., via an AST or static analysis) to determine class relationships and then produce a `classDiagram` in Mermaid syntax. *For example, tools exist that analyze Python code to output Mermaid UML diagrams of classes, their methods, attributes, and relationships[github.com](mdc:https:/github.com/diceroll123/pymermaider#:~:text=,visualize class hierarchies and relationships), proving this approach is feasible.* The diagrams should be detailed, including key methods and attributes of each class, to give a visual summary of the API.

- **Sequence Diagrams:** For dynamic behaviors or interactions, include **sequence diagrams** (also via Mermaid) to illustrate typical flows. For instance, if a certain function triggers a sequence of calls across multiple classes, or if an object goes through a lifecycle of method calls, a Mermaid `sequenceDiagram` can depict this step-by-step. This is especially useful for complex processes or algorithms in the project (such as a request handling flow, a data processing pipeline, or an example of a Retrieval-Augmented Generation query flow in this RAG project). Each sequence diagram should be accompanied by an explanation of the scenario it represents.

- **Other Diagram Types:** If useful, incorporate other diagram types supported by Mermaid to clarify logic:

  - **Flowcharts:** to outline decision logic in complex functions.
  - **State diagrams:** to show state transitions if the project involves stateful components.
  - **Entity-relationship diagrams:** if the project interacts with databases or has data models.

  All diagrams should be generated automatically from the code or configuration when possible, ensuring they stay in sync with the codebase. The rule should encourage using the **latest code structure** to regenerate diagrams, so they update whenever the code changes (e.g., new classes show up in the class diagram when added).

## Ensuring Comprehensive, Up-to-Date Content

- **Internal Details:** The documentation must not only describe the “what” and “how,” but also the “why.” It should capture internal details such as the reasoning behind certain implementations, descriptions of private helper functions, and the role of important internal variables. Essentially, treat this as both user-facing documentation *and* developer documentation. By including internal/private elements, we ensure that a developer reading the docs can understand the inner workings and maintain or extend the code more easily.
- **Lucid Explanations:** Write everything in clear, accessible language. Avoid overly terse descriptions – instead, provide enough background so that even someone new to the project can follow along. Use analogies or higher-level descriptions where helpful. For example, if a class implements a specific algorithm or design pattern, mention that and briefly describe it in context. Aim for a tutorial-like tone in examples, while being thorough in API details.
- **Admonitions and Notes:** Leverage MkDocs Material’s **admonition blocks** to highlight important information. For instance, use a “Note” admonition for tips or caveats about using a class, a “Warning” for pitfalls or deprecated elements, and “Example” blocks to showcase sample usages. These callouts make the documentation more engaging and informative.
- **Cross-References:** Cross-link relevant parts of the documentation. If a class is closely related to another (e.g., one is a subclass of another or they collaborate), make sure each page references the other (e.g., “See also: `[OtherClassName](mdc:OtherClassName.md)`”). Also link from a method to the class it belongs to (though the page structure might already imply that). These cross-references help readers navigate the docs without getting lost.
- **Keep Documentation in Sync:** Whenever the code changes (new classes/functions added, signatures changed, logic updated), the corresponding documentation should be regenerated or updated. The rule should prompt the AI to re-scan the code and adjust the Markdown files accordingly, rather than leaving stale information. Because the `docs/` are part of version control, developers will commit these updates to git, ensuring the repo always contains documentation matching the current code. Ideally, incorporate this into the development workflow – for example, run the documentation generation as part of CI or a pre-commit hook, so that any discrepancies can be caught and fixed immediately.
- **Version Control Considerations:** Since the docs are version-controlled, ensure that large automated edits are reviewable. Possibly group changes logically (e.g., if a class is renamed, the generator should also handle renaming the file and updating links). The rule could include instructions to output a summary of changes made to documentation, helping the developer review them before committing.

## Additional Enhancements and Best Practices

- **Global Project Overview:** In addition to per-package overviews, consider creating a **top-level overview** page (e.g., `index.md` in the root of `docs/`) that gives a high-level description of the entire project. This page can include an **architecture diagram** (using Mermaid or an external image) that shows how all the packages or major components fit together. It should also link to the package overviews, serving as a starting point for readers. This addresses the project’s big picture before delving into details.
- **Automatic Diagram Generation via AST:** To reduce manual work and errors in diagrams, the rule can employ AST parsing or static code analysis to feed Mermaid diagrams. For example, by analyzing class definitions and their imports, one can programmatically construct class diagrams. This approach is validated by existing tools like *pymermaider*, which parses Python code to output Mermaid UML diagrams of class hierarchies[github.com](mdc:https:/github.com/diceroll123/pymermaider#:~:text=,visualize class hierarchies and relationships). Integrating a similar approach ensures diagrams are accurate and update with code changes. The AI should be instructed to either use such a tool or replicate its logic when generating diagrams.
- **Styling and Formatting:** Make sure the generated Markdown adheres to consistent style. Use headings (e.g., `### Methods` under a class page to list methods), bullet points for lists of items (like parameters or class list in a package), and tables if needed for comparison or summary. Keep paragraphs short (3-5 sentences) for readability, and include code fences for code examples. This will produce clean, Material-themed documentation that is easy to read and navigate.
- **Leverage MkDocs Features:** Since the project uses MkDocs Material and various plugins, take advantage of them:
  - The **`mkdocstrings`** plugin can automatically pull in signatures and docstrings from the code, which we can use to verify our AI-generated content or even embed it directly for accuracy. We should ensure our documentation structure is compatible with or enhances `mkdocstrings` output rather than duplicating it. For example, we might include a `::: module.ClassName` directive to auto-document the class, and then add diagrams and additional notes around it.
  - The **Mermaid integration** means we can directly embed our `classDiagram` and `sequenceDiagram` blocks in the Markdown, and they will render in the site. We should format these diagrams clearly (perhaps with comments or labels in the Mermaid code for clarity).
  - The **`awesome-pages`** plugin will help organize the nav automatically, but we should still ensure the files are named and placed correctly so the site navigation is intuitive (e.g. each package folder in docs having an `index.md` and children pages for classes).
- **Review and Iteration:** Finally, treat the generated documentation as living content. The rule should encourage reviewing the AI-generated docs for correctness and clarity. Over time, if certain sections are lacking (e.g., a particularly tricky function might need a deeper explanation or an external reference), the documentation rule can be refined to handle that. The goal is to make the documentation self-explanatory and helpful to both new users and experienced developers maintaining the project.
